{
  "data": {
    "lesson": {
      "id": 931306,
      "key": "6ad7eae3-77b6-4c93-ba97-bfd04b1cdf6e",
      "title": "Smart Pointers",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson the three types of smart pointers in C++ are presented and compared. In addition, it is shown how to transfer ownership from one program part to another using copy and move semantics.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/6ad7eae3-77b6-4c93-ba97-bfd04b1cdf6e/931306/1570750214951/Smart+Pointers+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/6ad7eae3-77b6-4c93-ba97-bfd04b1cdf6e/931306/1570750211551/Smart+Pointers+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 931307,
          "key": "7e61918e-ca32-4a40-8051-12d84e3c5e39",
          "title": "Resource Acquisition is Initialization",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7e61918e-ca32-4a40-8051-12d84e3c5e39",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 931310,
              "key": "712065f8-2073-4ac4-9a34-891d4ef88872",
              "title": "ND213 C03 L05 01.1 Resource Acquisition Is Initialization (RAII) HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ScH7IDXJ8d0",
                "china_cdn_id": "ScH7IDXJ8d0.mp4"
              }
            },
            {
              "id": 931311,
              "key": "cd662b61-f12d-4ba5-95e6-533cf27e1ade",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r859981c931307xJUPYTERLtf6w5vg3",
              "pool_id": "jupyterlab",
              "view_id": "jupyter-lab-6ynb5",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "pageEnd": "",
                    "pageStart": "",
                    "allowSubmit": false,
                    "defaultPath": "/",
                    "actionButtonText": ""
                  },
                  "kind": "jupyter-lab"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 931312,
              "key": "0ca31a36-6444-4da2-b151-4b161f65d138",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Outro",
              "instructor_notes": ""
            },
            {
              "id": 931313,
              "key": "77cae5fa-1ca6-4c2a-b6e4-a84f40eee814",
              "title": "ND213 C03 L05 01.2 Resource Acquisition Is Initialization (RAII) HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "qCZT8tKatrU",
                "china_cdn_id": "qCZT8tKatrU.mp4"
              }
            }
          ]
        },
        {
          "id": 850781,
          "key": "506668d6-3e05-4e93-a127-fe2b39f22868",
          "title": "Bjarne on RAII",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "506668d6-3e05-4e93-a127-fe2b39f22868",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 850784,
              "key": "d9d79ace-13d0-4b0b-9938-be0bc8b4c190",
              "title": "ND213 C03 RAII What Is RAII",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "eSCgbrpSNj0",
                "china_cdn_id": "eSCgbrpSNj0.mp4"
              }
            }
          ]
        },
        {
          "id": 931308,
          "key": "de324e66-c13e-4143-80da-15aa8802a014",
          "title": "Smart Pointers",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "de324e66-c13e-4143-80da-15aa8802a014",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 931314,
              "key": "ab9c7c2b-a504-4e09-845e-761da2d846d0",
              "title": "ND213 C03 L05 02.1 Smart Pointers HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Nr3qzOklQNk",
                "china_cdn_id": "Nr3qzOklQNk.mp4"
              }
            },
            {
              "id": 931316,
              "key": "2b460127-974a-4a9e-b7fe-ee5446c1acbb",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r859981c931308xJUPYTERLqe3a4k79",
              "pool_id": "jupyterlab",
              "view_id": "jupyter-lab-u482n",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "videos": [
                      {
                        "id": "101707",
                        "duration": 201,
                        "subtitles": [],
                        "topher_id": "925219a8-dc8f-11e9-b7ab-0242ac11000d",
                        "youtube_id": "Sjq5L4o8lAo",
                        "transcodings": {
                          "uri_hls": "https://video.udacity-data.com/topher/2019/September/5d865440_nd213-c03-l05-02.2-smart-pointers-sc/hls/playlist.m3u8",
                          "uri_480p_mp4": "https://video.udacity-data.com/topher/2019/September/5d865440_nd213-c03-l05-02.2-smart-pointers-sc/nd213-c03-l05-02.2-smart-pointers-sc_480p.mp4",
                          "uri_720p_mp4": "https://video.udacity-data.com/topher/2019/September/5d865440_nd213-c03-l05-02.2-smart-pointers-sc/nd213-c03-l05-02.2-smart-pointers-sc_720p.mp4",
                          "uri_480p_1000kbps_mp4": "https://video.udacity-data.com/topher/2019/September/5d865440_nd213-c03-l05-02.2-smart-pointers-sc/nd213-c03-l05-02.2-smart-pointers-sc_480p_1000kbps.mp4"
                        }
                      }
                    ],
                    "pageEnd": "",
                    "pageStart": "",
                    "allowSubmit": false,
                    "defaultPath": "/",
                    "actionButtonText": ""
                  },
                  "kind": "jupyter-lab"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 931317,
              "key": "bb2f68c4-302f-49da-94d2-bb6f5b3a8ee2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Outro",
              "instructor_notes": ""
            },
            {
              "id": 931318,
              "key": "82d22a8d-d2c1-4c1a-be1e-2a6157319189",
              "title": "ND213 C03 L05 02.3 Smart Pointers HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "KsCza62MCSM",
                "china_cdn_id": "KsCza62MCSM.mp4"
              }
            }
          ]
        },
        {
          "id": 850808,
          "key": "d4de5d92-27d5-4169-ab9e-26b93ea41cd7",
          "title": "Bjarne on Smart Pointers",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d4de5d92-27d5-4169-ab9e-26b93ea41cd7",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 850809,
              "key": "9348d1d0-ff22-4859-9661-8c64dcc556bb",
              "title": "ND213 C03 Smart Pointers What Are Pointers- 1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "4HJ1unZb9l0",
                "china_cdn_id": "4HJ1unZb9l0.mp4"
              }
            }
          ]
        },
        {
          "id": 931309,
          "key": "3376e640-80ca-4763-96f2-118d39c22972",
          "title": "Transferring Ownership",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3376e640-80ca-4763-96f2-118d39c22972",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 931319,
              "key": "1cf9bed8-05f4-4ddd-aec1-cbc565d16dd3",
              "title": "ND213 C03 L05 03.1 Transferring Ownership HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "fVnLp5BOvzo",
                "china_cdn_id": "fVnLp5BOvzo.mp4"
              }
            },
            {
              "id": 931320,
              "key": "e7053df8-c467-4a48-8991-1ee1dabf5102",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the previous section, we have taken a look at the three smart pointer types in C++. In addition to smart pointers, you are now also familiar with move semantics, which is of particular importance in this section. In the following, we will discuss how to properly pass and return smart pointers to functions and vice-versa. In modern C++, there are various ways of doing this and in many cases, the method of choice has an impact on both performance and code robustness. The basis of this section are the C++ core guidelines on smart pointers, some of which we will be examining in the following.",
              "instructor_notes": ""
            },
            {
              "id": 931321,
              "key": "3db5c110-edf8-4f87-9c76-0c65af34bd64",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r859981c931309xJUPYTERLmnsvv3ij",
              "pool_id": "jupyterlab",
              "view_id": "jupyter-lab-sbxh5",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "videos": [
                      {
                        "id": "101708",
                        "duration": 282,
                        "subtitles": [],
                        "topher_id": "a72a648d-dc8f-11e9-8d55-0242ac11001f",
                        "youtube_id": "BbgLeyReV1g",
                        "transcodings": {
                          "uri_hls": "https://video.udacity-data.com/topher/2019/September/5d865463_nd213-c03-l05-03.2-transferring-ownership-sc/hls/playlist.m3u8",
                          "uri_480p_mp4": "https://video.udacity-data.com/topher/2019/September/5d865463_nd213-c03-l05-03.2-transferring-ownership-sc/nd213-c03-l05-03.2-transferring-ownership-sc_480p.mp4",
                          "uri_720p_mp4": "https://video.udacity-data.com/topher/2019/September/5d865463_nd213-c03-l05-03.2-transferring-ownership-sc/nd213-c03-l05-03.2-transferring-ownership-sc_720p.mp4",
                          "uri_480p_1000kbps_mp4": "https://video.udacity-data.com/topher/2019/September/5d865463_nd213-c03-l05-03.2-transferring-ownership-sc/nd213-c03-l05-03.2-transferring-ownership-sc_480p_1000kbps.mp4"
                        }
                      }
                    ],
                    "pageEnd": "",
                    "pageStart": "",
                    "allowSubmit": false,
                    "defaultPath": "/",
                    "actionButtonText": ""
                  },
                  "kind": "jupyter-lab"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 932050,
              "key": "8b20a6ce-ee67-44f1-94ed-0af79e6291b2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Best-Practices for Passing Smart Pointers\nThis sections contains a condensed summary of when (and when not) to use smart pointers and how to properly pass them between functions. This section is intended as a guide for your future use of this important feature in modern C++ and will hopefully encourage you not to ditch raw pointers altogether but instead to think about where your code could benefit from smart pointers - and when it would most probably not.\n\nThe following list contains all the variations (omitting `const`) of passing an object to a function: \n\n```\nvoid f( object* );  // (a)\nvoid f( object& ); // (b)\nvoid f( unique_ptr<object> ); // (c)\nvoid f( unique_ptr<object>& ); // (d)\nvoid f( shared_ptr<object> ); // (e)\nvoid f( shared_ptr<object>& ); // (f)\n```\n\n\n### The Preferred Way\nThe preferred way of to pass object parameters is by using a) or b) : \n```\nvoid f( object* );             \nvoid f( object& );            \n```\n\nIn doing so, we do not have to worry about the lifetime policy a caller might have implemented. Using a specific smart pointer in a case where we only want to observe an object or manipulate a member might be overly restrictive. \n\nWith the non-owning raw pointer `*` or the reference `&` we can observe an object from which we can assume that its lifetime will exceed the lifetime of the function parameter. In concurrency however, this might not be the case, but for linear code we can safely assume this. \n\nTo decide wether a * or & is more appropriate, you should think about wether you need to express that there is no object. This can only be done with pointers by passing e.g. `nullptr`. In most other cases, you should use a reference instead. \n\n\n### The Object Sink\nThe preferred way of passing an object to a function so that the function takes ownership of the object (or „consumes“ it) is by using method c) from the above list: \n\n`void f( unique_ptr<object> );`\n\nIn this case, we are passing a unique pointer by value from caller to function, which then takes ownership of the the pointer and the underlying object. This is only possible using move semantics as there may be only a single reference to the object managed by the unique pointer. \n\nAfter the object has been passed in this way, the caller will have an invalid unique pointer and the function to which the object now belongs may destroy it or move it somewhere else. \n\nUsing `const` with this particular call does not make sense as it models an ownership transfer so the source will be definitely modified. \n\n\n### In And Out Again 1\nIn some cases, we want to modify a unique pointer (not necessarily the underlying object) and re-use it in the context of the caller. In this case, method d) from the above list might be most suitable: \n\n`void f( unique_ptr<object>& );`\n\nUsing this call structure, the function states that it might modify the smart pointer, e.g. by redirecting it to another object. It is not recommended to use it for accepting an object only because we should avoid restricting ourselves unnecessarily to a particular object lifetime strategy on the caller side. \n\nUsing `const` with this call structure is not recommendable as we would not be able to modify the `unique_ptr` in this case. In case you want to modify the underlying object, use method a) instead. \n\n\n### Sharing Object Ownership\nIn the last examples, we have looked at strategies involving unique ownership. In this example, we want to express that a function will store and share ownership of an object on the heap. This can be achieved by using method e) from the list above: \n\n`void f( shared_ptr<object> )`\n\nIn this example, we are making a copy of the shared pointer passed to the function. In doing so, the internal reference counter within all shared pointers referring to the same heap object is incremented by one. \n\nThis strategy can be recommended for cases where the function needs to retain a copy of the shared_ptr and thus share ownership of the object. This is of interest when we need access to smart pointer functions such as the reference count or we must make sure that the object to which the shared pointer refers is not prematurely deallocated (which might happen in concurrent programming). \n\nIf the local scope of the function is not the final destination, a shared pointer can also be moved, which does not increase the reference count and is thus more effective.\n\nA disadvantage of using a shared_ptr as a function argument is that the function will be limited to using only objects that are managed by shared pointers - which limits flexibility and reusability of the code. \n\n### In And Out Again 2\nAs with unique pointers, the need to modify shared pointers and re-use them in the context of the caller might arise. In this case, method f) might be the right choice: \n\n`void f( shared_ptr<object>& );` \n\nThis particular way of passing a shared pointer expresses that the function f will modify the pointer itself. As with method e), we will be limiting the usability of the function to cases where the object is managed by a shared_ptr and nothing else. \n\n\n## Last Words\nThe topic of smart pointers is a complex one. In this course, we have covered many basics and some of the more advanced concepts. However, for some cases there are more aspects to consider and features to use when integrating smart pointers into your code. The [full set of smart pointer rules](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#rsmart-smart-pointers) in the C++ guidelines is a good start to dig deeper into one of the most powerful features of modern C++.",
              "instructor_notes": ""
            },
            {
              "id": 931322,
              "key": "34b12ff3-f060-4793-a83d-ed2d742f6053",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Outro",
              "instructor_notes": ""
            },
            {
              "id": 931323,
              "key": "44faff54-8a4c-411e-9c08-f3ac67823416",
              "title": "ND213 C03 L05 03.3 Transferring Ownership HS",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "cNqv8RqbuVM",
                "china_cdn_id": "cNqv8RqbuVM.mp4"
              }
            }
          ]
        },
        {
          "id": 850805,
          "key": "a41bfbfe-fe12-4770-81d1-dfa217a64fb6",
          "title": "Bjarne on Importance of Scope",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a41bfbfe-fe12-4770-81d1-dfa217a64fb6",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 850806,
              "key": "41caf2cd-4601-4a9d-9140-46311a8acaaf",
              "title": "ND213 C03 Destructors Why Is Scope Important To C++- 1",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "-k9C4fD1lx4",
                "china_cdn_id": "-k9C4fD1lx4.mp4"
              }
            }
          ]
        }
      ]
    }
  }
}