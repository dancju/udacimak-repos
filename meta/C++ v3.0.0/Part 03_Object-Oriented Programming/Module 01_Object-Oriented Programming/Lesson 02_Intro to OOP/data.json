{
  "data": {
    "lesson": {
      "id": 833236,
      "key": "287ef495-0297-459f-b339-cfe087c7b11a",
      "title": "Intro to OOP",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson, you will explore some of the basic object oriented functionality of the C++ language.",
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/287ef495-0297-459f-b339-cfe087c7b11a/833236/1581974707257/Intro+to+OOP+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/287ef495-0297-459f-b339-cfe087c7b11a/833236/1581974700768/Intro+to+OOP+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 833252,
          "key": "5e43b9b0-1aa6-4470-8611-19eab60b3a8b",
          "title": "Classes and OOP",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "5e43b9b0-1aa6-4470-8611-19eab60b3a8b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 843400,
              "key": "647065cf-656a-469f-9661-7b508e04cf9b",
              "title": "ND213 A05 Classes And OOP",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "0Z9vdXNyEVc",
                "china_cdn_id": "0Z9vdXNyEVc.mp4"
              }
            }
          ]
        },
        {
          "id": 845684,
          "key": "7b17476e-b6a0-489b-934a-2fda48c742da",
          "title": "Bjarne On Classes In C++",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7b17476e-b6a0-489b-934a-2fda48c742da",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845690,
              "key": "bc158085-1440-43b5-9f1e-ed965075bb2d",
              "title": "ND213 C02 Classes Are For Applications Why Does C++ Have Classes-",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "leLjGXFcycE",
                "china_cdn_id": "leLjGXFcycE.mp4"
              }
            }
          ]
        },
        {
          "id": 831164,
          "key": "a19329b5-7a2a-407c-8571-bff7827f50a4",
          "title": "Jupyter Notebooks",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a19329b5-7a2a-407c-8571-bff7827f50a4",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 831165,
              "key": "1fd81810-8cc3-46ea-b10d-2a6adb55c527",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Jupyter Notebooks",
              "instructor_notes": ""
            },
            {
              "id": 838957,
              "key": "5f87ab9c-653f-484f-a145-f6fefd96bd50",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2019/March/5c87e945_screen-shot-2019-03-12-at-10.15.14-am/screen-shot-2019-03-12-at-10.15.14-am.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/5f87ab9c-653f-484f-a145-f6fefd96bd50",
              "caption": "",
              "alt": "",
              "width": 1814,
              "height": 836,
              "instructor_notes": null
            },
            {
              "id": 831166,
              "key": "c8e357d0-7d28-47a6-b634-f6405af30873",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Jupyter with C++\n\nIn this lesson, you'll be writing and testing lots of C++ code. C++ is a _compiled_ language, which is to say there is a separate program - the compiler - that converts your code to an executable program that the computer can run. This means that, after you save a new C++ program to file, running it is normally a two step process:\n1. Compile your code with a compiler.\n2. Run the executable file that the compiler outputs.\n\nFor example, in the notebook exercises that follow, you'll be saving your code in a file, let's say `filename.cpp` in a folder called `/code`.  To compile it using the C++17 standard, you can run the following command:\n```sh\ng++ -std=c++17 ./code/filename.cpp \n```\nAnd then to run the resulting executable file, you can run:\n```sh\n./a.out\n```\n\n## Jupyter Notebooks in Udacity Classroom\nIn this lesson, you will save, compile, and run executables over and over.  To make your life simpler, we've set things up so you can save, compile and run with the click of a single `Compile & Run` button in the [Jupyter](https://jupyter.org/index.html) Notebooks.\n \nLater, when you build the project, you'll move out of the notebooks and into a Linux virtual machine. At that point, you'll need to remember to compile and run the programs yourself!\n\nIf you haven't seen Jupyter Notebooks before, you can test one out below. A Notebook is a web application that allows for code, text, and visualizations to be combined and shared.\n\nCheck out the Notebook below for an example of how these will be used in the course. \n\nWhen you use a Notebook Workspace, we encourage you to expand to a full screen view. Click on the `EXPAND` button in the lower left corner.",
              "instructor_notes": ""
            },
            {
              "id": 831168,
              "key": "5fdcdcc3-b73c-4dfa-ba3d-db3bf7e3b57d",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-ul2hr",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Example_Notebook.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826361,
          "key": "43d6ad9b-8109-4022-a3d3-b6f5e53ed070",
          "title": "Structures",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "43d6ad9b-8109-4022-a3d3-b6f5e53ed070",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907246,
              "key": "615d9b1c-f8b5-4428-bc61-f1644ccc2a0b",
              "title": "Structures",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "iKIEdY_pdzY",
                "china_cdn_id": "iKIEdY_pdzY.mp4"
              }
            },
            {
              "id": 826806,
              "key": "781d1430-1f64-462a-8595-e2897e45c1a3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Structures\n\nStructures allow developers to create their own types (\"user-defined\" types) to aggregate data relevant to their needs.\n\nFor example, a user might define a `Rectangle` structure to hold data about rectangles used in a program.\n\n```\nstruct Rectangle {\n  float length;\n  float width;\n};\n```\n\n## Types\nEvery C++ variable is defined with a [type](http://www.cplusplus.com/doc/tutorial/variables/). \n\n```\nint value;\nRectangle rectangle;\nSphere earth;\n```\n\nIn this example, the \"type\" of `value` is `int`. Furthermore, `rectangle` is \"of type\" `Rectangle`, and `earth` has type `Sphere`.\n\n## Fundamental Types\n\nC++ includes [fundamental types](https://en.cppreference.com/w/cpp/language/types), such as `int` and `float`. These fundamental types are sometimes called [\"primitives\"](https://www.geeksforgeeks.org/c-data-types/).\n\nThe Standard Library [includes additional types](, such as `std::size_t` and `std::string`.\n\n## User-Defined Types\n\nStructures are \"user-defined\" types. Structures are a way for programmers to create types that aggregate and store data in way that makes sense in the context of a program.\n\nFor example, C++ does not have a fundamental type for storing a date. (The Standard Library does include types related to [time](https://en.cppreference.com/w/cpp/chrono), which can be converted to dates.)\n\nA programmer might desire to create a type to store a date.\n\nConsider the following example:\n\n```cpp\nstruct Date {\n  int day;\n  int month;\n  int year;\n};\n```\n\nThe code above creates a structure containing three \"member variables\" of type `int`: `day`, `month` and `year`. \n\nIf you then create an \"instance\" of this structure, you can initialize these member variables:\n\n```cpp\n// Create an instance of the Date structure\nDate date;\n// Initialize the attributes of Date\ndate.day = 1;\ndate.month = 10;\ndate.year = 2019;\n```",
              "instructor_notes": ""
            },
            {
              "id": 827585,
              "key": "218549af-bc0c-4ffb-b07b-318e5f3d5945",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-q6uus",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Structs.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 907247,
          "key": "d82204c1-6d42-4f73-ba87-120f09191ae2",
          "title": "Member Initialization",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d82204c1-6d42-4f73-ba87-120f09191ae2",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907248,
              "key": "7f9f62fa-50b6-4b86-b3ab-1991abc9513a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Member Initialization\nGenerally, we want to avoid instantiating an object with undefined members. Ideally, we would like all members of an object to be in a valid state once the object is instantiated. We can change the values of the members later, but we want to avoid any situation in which the members are ever in an invalid state or undefined.\n\nIn order to ensure that objects of our `Date` structure always start in a valid state, we can initialize the members from within the structure definition.\n\n```\nstruct Date {\n  int day{1};\n  int month{1};\n  int year{0};\n};\n```\nThere are also several other approaches to either initialize or assign member variables when the object is instantiated. For now, however, this approach ensures that every object of `Date` begins its life in a defined and valid state.",
              "instructor_notes": ""
            },
            {
              "id": 907249,
              "key": "a0788edb-c913-48f2-85f9-6c818907177c",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-eaysc",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Member_Initialization.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826497,
          "key": "14a32150-15e1-4de1-b84a-571a156c63a5",
          "title": "Access Specifiers",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "14a32150-15e1-4de1-b84a-571a156c63a5",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907250,
              "key": "bbc29c08-254f-44df-abe5-8846675a9ecf",
              "title": "Access Modifiers",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "ZEt2LTRc2D0",
                "china_cdn_id": "ZEt2LTRc2D0.mp4"
              }
            },
            {
              "id": 826500,
              "key": "bcc1983a-f5e5-4dd1-9277-2e09999aab31",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Access Specifiers\nMembers of a structure can be specified as `public` or `private`.\n\nBy default, all members of a structure are public, unless they are specifically marked `private`.\n\nPublic members can be changed directly, by any user of the object, whereas private members can only be changed by the object itself.\n\n## Private Members\nThis is an implementation of the `Date` structure, with all members marked as private.\n\n```\nstruct Date {\n private:\n  int day{1};\n  int month{1};\n  int year{0};\n};\n```\nPrivate members of a class are accessible only from within other member functions of the same class (or from their \"friends\", which we’ll  talk about later). \n\nThere is a third access modifier called `protected`, which implies that members are accessible from other member functions of the same class (or from their \"friends\"), and also from members of their derived classes. We'll also discuss about derived classes later, when we learn about inheritance.\n\n## Accessors And Mutators\nTo access private members, we typically define public \"accessor\" and \"mutator\" member functions (sometimes called \"getter\" and \"setter\" functions).\n```\nstruct Date {\n public:\n  int Day() { return day; }\n  void Day(int day) { this.day = day; }\n  int Month() { return month; }\n  void Month(int month) { this.month = month; }\n  int Year() { return year; }\n  void Year(int year) { this.year = year; }\n\n private:\n  int day{1};\n  int month{1};\n  int year{0};\n};\n```\n\n\nIn the last example, you saw how to create a setter function for class member attributes. Check out the code in the Notebook below to play around a bit with access modifiers as well as setter and getter functions!",
              "instructor_notes": ""
            },
            {
              "id": 827597,
              "key": "964bb597-591c-44ef-8975-67ec4401b751",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-n7pwl",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Access_Modifiers.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 843404,
              "key": "0ce82e0a-5586-4819-95cd-83492a02e570",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Avoid Trivial Getters And Setters\n\nSometimes accessors are not necessary, or even advisable. The [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rh-get) recommend, \"A trivial getter or setter adds no semantic value; the data item could just as well be public.\" \n\nHere is the example from the Core Guidelines:\n\n```\nclass Point {\n    int x;\n    int y;\npublic:\n    Point(int xx, int yy) : x{xx}, y{yy} { }\n    int get_x() const { return x; }  // const here promises not to modify the object\n    void set_x(int xx) { x = xx; }\n    int get_y() const { return y; }  // const here promises not to modify the object\n    void set_y(int yy) { y = yy; }\n    // no behavioral member functions\n};\n```\n\nThis `class` could be made into a `struct`, with no logic or \"invariants\", just passive data. The member variables could both be public, with no accessor functions:\n```\nstruct Point {   // Good: concise\n    int x {0};   // public member variable with a default initializer of 0\n    int y {0};   // public member variable with a default initializer of 0\n};\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 826492,
          "key": "19fc8c1c-9bef-4977-a381-25a8d283ebe9",
          "title": "Classes",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "19fc8c1c-9bef-4977-a381-25a8d283ebe9",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907251,
              "key": "e055c13e-9bdd-4d73-9046-a0271ac92207",
              "title": "Classes",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "FTzrwV2LP5g",
                "china_cdn_id": "FTzrwV2LP5g.mp4"
              }
            },
            {
              "id": 826495,
              "key": "4225d228-3315-49fb-b5a0-c1eb3744abda",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Classes\n\nClasses, like structures, provide a way for C++ programmers to aggregate data together in a way that makes sense in the context of a specific program. By convention, programmers use structures when member variables are independent of each other, and [use classes when member variables are related by an \"invariant\"](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c2-use-class-if-the-class-has-an-invariant-use-struct-if-the-data-members-can-vary-independently). \n\n## Invariants\nAn \"invariant\" is a rule that limits the values of member variables. \n\nFor example, in a `Date` class, an invariant would specify that the member variable `day` cannot be less than 0. Another invariant would specify that the value of `day` cannot exceed 28, 29, 30, or 31, depending on the month and year. Yet another invariant would limit the value of `month` to the range of 1 to 12.\n\n## `Date` Class\n\nLet's define a `Date` class:\n\n```cpp\n// Use the keyword “class” to define a Date class:\nclass Date {\n  int day{1};\n  int month{1};\n  int year{0};\n};\n```\n\nSo far, this class definition provides no invariants. The data members can vary independently of each other.\n\nThere is one subtle but important change that takes place when we change `struct Date` to `class Date`. By default, all members of a `struct` default to public, whereas all members of a `class` default to private. Since we have not specified access for the members of `class Date`, all of the members are private. In fact, we are not able to assign value to them at all!\n\n### `Date` Accessors And Mutators\nAs the first step to adding the appropriate invariants, let's specify that the member variable `day` is private. In order to access this member, we'll provide accessor and mutatot functions. Then we can add the appropriate invariants to the mutators.\n\n```cpp\nclass Date {\n public:\n  int Day() { return day_; }\n  void Day(int d) { day_ = d; }\n\n private:\n  int day_{1};\n  int month_{1};\n  int year_{0};\n};\n```\n\n### `Date` Invariants\nNow we can add the invariants within the mutators.\n```cpp\nclass Date {\n public:\n  int Day() { return day; }\n  void Day(int d) {\n    if (d >= 1 && d <= 31) day_ = d;\n  }\n\n private:\n  int day_{1};\n  int month_{1};\n  int year_{0};\n};\n```\nNow we have a set of invariants for the the class members!\n\nAs a general rule, member data subject to an invariant should be specified `private`, in order to enforce the invariant before updating the member's value.",
              "instructor_notes": ""
            },
            {
              "id": 827592,
              "key": "af130cdf-c483-4c04-bd81-3c3c74a1949a",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-dkhrv",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Classes.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 844191,
          "key": "d268a864-93f4-4af2-a231-a8db5b5da349",
          "title": "Encapsulation and Abstraction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d268a864-93f4-4af2-a231-a8db5b5da349",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 844192,
              "key": "0a22695e-e82d-470d-b24b-5330aefd2043",
              "title": "ND213 A06 Encapsulation And Abstraction",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "KXojXgyW-O8",
                "china_cdn_id": "KXojXgyW-O8.mp4"
              }
            }
          ]
        },
        {
          "id": 845685,
          "key": "6e864628-eee9-4256-82fa-821bedb7b584",
          "title": "Bjarne on Encapsulation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6e864628-eee9-4256-82fa-821bedb7b584",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845686,
              "key": "df8a557e-43b2-4757-9209-0ca0289dabc0",
              "title": "ND213 C02 Encapsulations What Is Encapsulation-",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "M27atfK73_s",
                "china_cdn_id": "M27atfK73_s.mp4"
              }
            }
          ]
        },
        {
          "id": 860368,
          "key": "bcb82f6e-6e62-452e-a126-26a8ac0774bf",
          "title": "Constructors",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "bcb82f6e-6e62-452e-a126-26a8ac0774bf",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 860369,
              "key": "d8148a0d-d043-4c89-98cb-b47150b4123d",
              "title": "ND213 A09 Constructors",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "zw5fqCmxD8o",
                "china_cdn_id": "zw5fqCmxD8o.mp4"
              }
            },
            {
              "id": 907252,
              "key": "10cfa74d-4536-47e0-ada7-b5592b405fb0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Constructors\n\nConstructors are member functions of a class or struct that initialize an object. The Core Guidelines [define a constructor]((http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#glossary)) as:\n> *constructor*: an operation that initializes (“constructs”) an object. Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor).\n\nA constructor can take arguments, which can be used to assign values to member variables.\n\n```\nclass Date {\n public:\n  Date(int d, int m, int y) {  // This is a constructor.\n    Day(d);\n  }\n  int Day() { return day; }\n  void Day(int d) {\n    if (d >= 1 && d <= 31) day = d;\n  }\n  int Month() { return month; }\n  void Month(int m) {\n    if (m >= 1 && m <= 12) month = m;\n  }\n  int Year() { return year_; }\n  void Year(int y) { year = y; }\n\n private:\n  int day{1};\n  int month{1};\n  int year{0};\n};\n```\n\nAs you can see, a constructor is also able to call other member functions of the object it is constructing. In the example above, `Date(int d, int m, int y)` assigns a member variable by calling `Day(int d)`.",
              "instructor_notes": ""
            },
            {
              "id": 907253,
              "key": "f6e5b3f1-787d-437e-9526-ad8bb11a8a3e",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-fl44i",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Constructors.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            },
            {
              "id": 907254,
              "key": "dda14f31-211b-49e5-ba37-92ddf11eae2f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Default Constructor\nA class object is always initialized by calling a constructor. That might lead you to wonder how it is possible to initialize a class or structure that does not define any constructor at all.\n\nFor example:\n```\nclass Date { \n  int day{1};\n  int month{1};\n  int year{0};\n};\n```\nWe can initialize an object of this class, even though this class does not explicitly define a constructor.\n\nThis is possible because of the [default constructor](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cctor-constructors-assignments-and-destructors). [The compiler will define a default constructor](https://en.cppreference.com/w/cpp/language/default_constructor), which accepts no arguments, for any class or structure that does not contain an explicitly-defined constructor.\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 907259,
          "key": "6976400f-04c0-470a-8092-6e9faa7bf65c",
          "title": "Scope Resolution",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6976400f-04c0-470a-8092-6e9faa7bf65c",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907268,
              "key": "2d47268e-d17b-4934-8b22-3a32d6b0a59b",
              "title": "Scope Resolution",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "U2ItvJEwuHQ",
                "china_cdn_id": "U2ItvJEwuHQ.mp4"
              }
            },
            {
              "id": 907266,
              "key": "38325027-cf5a-4e0f-928f-e3cb99399a5c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Scope Resolution\nC++ allows different [identifiers](https://en.cppreference.com/w/cpp/language/identifiers) (variable and function names) to have the same name, as long as they have different scope. For example, two different functions can each declare the variable `int i`, because each variable only exists within the scope of its parent function.\n\nIn some cases, scopes can overlap, in which case the compiler may need assistance in determining which identifier the programmer means to use. The process of determining which identifier to use is called [\"scope resolution\"](https://docs.microsoft.com/en-us/cpp/cpp/scope-resolution-operator?view=vs-2019).\n\n## Scope Resultion Operator\n`::` is the [scope resolution operator](https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_74/rzarg/cplr175.htm). We can use this operator to specify which namespace or class to search in order to resolve an identifier.\n\n```\nPerson::move(); \\\\ Call the move the function that is a member of the Person class.\nstd::map m; \\\\ Initialize the map container from the C++ Standard Library.  \n```\n\n## Class\nEach class provides its own scope. We can use the scope resolution operator to specify identifiers from a class.\n\nThis becomes particularly useful if we want to separate class *declaration* from class *definition*.\n\n```\nclass Date {\n public:\n  int Day() const { return day; }\n  void Day(int day);  // Declare member function Date::Day().\n  int Month() const { return month; }\n  void Month(int month) {\n    if (month >= 1 && month <= 12) Date::month = month;\n  }\n  int Year() const { return year; }\n  void Year(int year) { Date::year = year; }\n\n private:\n  int day{1};\n  int month{1};\n  int year{0};\n};\n\n// Define member function Date::Day().\nvoid Date::Day(int day) {\n  if (day >= 1 && day <= 31) Date::day = day;\n}\n```\n\n## Namespaces\n[Namespaces](https://en.cppreference.com/w/cpp/language/namespace) allow programmers to group logically related variables and functions together. Namespaces also help to avoid conflicts between to variables that have the same name in different parts of a program.\n\n```\nnamespace English {\nvoid Hello() { std::cout << \"Hello, World!\\n\"; }\n}  // namespace English\n\nnamespace Spanish {\nvoid Hello() { std::cout << \"Hola, Mundo!\\n\"; }\n}  // namespace Spanish\n\nint main() {\n  English::Hello();\n  Spanish::Hello();\n}\n```\n\nIn this example, we have two different `void Hello()` functions. If we put both of these functions in the same namespace, they would conflict and the program would not compile. However, by declaring each of these functions in a separate namespace, they are able to co-exist. Furthermore, we can specify which function to call by prefixing `Hello()` with the appropriate namespace, followed by the `::` operator.\n\n### `std` Namespace\nYou are already familiar with the `std` namespace, even if you didn't realize quite what it was. `std` is the namespace used by the [C++ Standard Library](https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library).\n\nClasses like [`std::vector`](https://en.cppreference.com/w/cpp/container/vector) and functions like [`std::sort`](https://en.cppreference.com/w/cpp/algorithm/sort) are defined within the `std` namespace.",
              "instructor_notes": ""
            },
            {
              "id": 907267,
              "key": "77794331-44f0-446b-9d6c-ed2a0f68547d",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-mpe5y",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Scope_Resolution.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 831328,
          "key": "108faf87-9517-47f8-877b-66f2a08ead89",
          "title": "Initializer Lists",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "108faf87-9517-47f8-877b-66f2a08ead89",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907264,
              "key": "9c7cb682-faae-47d0-aeaf-c121d70cd343",
              "title": "Initializer Lists",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "cqKuYu1oiow",
                "china_cdn_id": "cqKuYu1oiow.mp4"
              }
            },
            {
              "id": 831329,
              "key": "8e960a99-4278-4e3a-8a8a-747c2b6183e7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Initializer Lists\n[Initializer lists](https://en.cppreference.com/w/cpp/language/initializer_list) initialize member variables to specific values, just before the class constructor runs. This initialization ensures that class members are automatically initialized when an instance of the class is created.\n\n```cpp\nDate::Date(int day, int month, int year) : year_(y) {\n  Day(day);\n  Month(month);\n}\n```\n\nIn this example, the member value `year` is initialized through the initializer list, while `day` and `month` are assigned from within the constructor. Assigning `day` and `month` allows us to apply the invariants set in the mutator.\n\nIn general, [prefer initialization to assignment](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c49-prefer-initialization-to-assignment-in-constructors). Initialization sets the value as soon as the object exists, whereas assignment sets the value only after the object comes into being. This means that assignment creates and opportunity to accidentally use a variable before its value is set.\n\nIn fact, initialization lists ensure that member variables are initialized *before* the object is created. This is why class member variables can be declared `const`, but only if the member variable is initialized through an initialization list. Trying to initialize a `const` class member within the body of the constructor will not work.\n\n## Instructions\n1. Declare `class Person`.\n2. Add `std::string name` to `class Person`.\n3. Create a constructor for `class Person`.\n3. Add an initializer list to the constructor.\n4. Create class object.",
              "instructor_notes": ""
            },
            {
              "id": 831897,
              "key": "740a5a33-5c3c-45c5-a6eb-9808b6cd29d7",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-m3q9b",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/InitializationList_Lab1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 831330,
          "key": "3f73d784-391f-483d-926d-0fadddc4022b",
          "title": "Initializing Constant Members",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "3f73d784-391f-483d-926d-0fadddc4022b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 907269,
              "key": "a54430f0-27b5-45b3-a80e-81b95e2f86b0",
              "title": "Initializing Constant Members",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Ms4Li58ZvwA",
                "china_cdn_id": "Ms4Li58ZvwA.mp4"
              }
            },
            {
              "id": 831331,
              "key": "1380ac6c-afeb-4384-9256-e38273fdb181",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: Constructor Syntax\nInitializer lists exist for a number of reasons. First, the compiler can optimize initialization faster from an initialization list than from within the constructor. \n\nA second reason is a bit of a technical paradox. If you have a `const` class attribute, you can only initialize it using an initialization list.  Otherwise, you would violate the `const` keyword simply by initializing the member in the constructor! \n\nThe third reason is that attributes defined as [references](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-glossary) must use initialization lists.\n\nThis exercise showcases several advantages of initializer lists.\n\n## Instructions\n1. Modify the exist code to use an initialization list.\n2. Verify that the test passes.",
              "instructor_notes": ""
            },
            {
              "id": 831898,
              "key": "0353dfc8-0a21-436b-90d7-07ce66c58e59",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-trblz",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/InitializationList_Lab2.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826366,
          "key": "360ea90c-ec19-48a5-bc0b-b6a7e435d0e7",
          "title": "Encapsulation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "360ea90c-ec19-48a5-bc0b-b6a7e435d0e7",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909579,
              "key": "16742a58-d50e-4419-bd41-f80a9a0fc269",
              "title": "Encapsulation",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "1-j6AxEoK3c",
                "china_cdn_id": "1-j6AxEoK3c.mp4"
              }
            },
            {
              "id": 826367,
              "key": "4cb5138c-867a-4cbf-b642-72b7795cecdb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n# Encapsulation\n[Encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming%29) is the grouping together of data and logic into a single unit. In object-oriented programming, classes encapsulate data and functions that operate on that data.\n\nThis can be a delicate balance, because on the one hand we want to group together relevant data and functions, but on the hand we want to [limit member functions to only those functions that need direct access to the representation of a class](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c4-make-a-function-a-member-only-if-it-needs-direct-access-to-the-representation-of-a-class).\n\nIn the context of a `Date` class, a function `Date Tomorrow(Date const & date)` probably does not need to be encapsulated as a class member. It can exist outside the `Date` class.\n\nHowever, a function that calculates the number of days in a month probably should be encapsulated with the class, because the class needs this function in order to operate correctly.",
              "instructor_notes": ""
            },
            {
              "id": 827600,
              "key": "5887b533-2869-495f-85aa-8a1f000ecc99",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-t3m7t",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Encapsulation_Example.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826835,
          "key": "d7ecc801-1a47-41de-b486-d7619031dba6",
          "title": "Accessor Functions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d7ecc801-1a47-41de-b486-d7619031dba6",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909580,
              "key": "79fbb88b-0df3-49b2-b3bf-0c8347edc4c4",
              "title": "Accessors",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "HfVOiSpzFaA",
                "china_cdn_id": "HfVOiSpzFaA.mp4"
              }
            },
            {
              "id": 826837,
              "key": "2beae0d4-dd0b-4f6a-92ac-493b93217e96",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Accessor Functions\nAccessor functions are public member functions that allow users to access an object's data, albeit indirectly.\n\n## `const`\nAccessors should only retrieve data. They should not change the data stored in the object. \n\nThe main role of the `const` specifier in accessor methods is to protect member data. When you specify a member function as `const`, the compiler will prohibit that function from changing any of the object's member data.\n\n## Exercise: Bank Account Class\nYour task is to design and implement class called `BankAccount`. This will be a generic account defined by its account number, the name of the owner and the funds available. \n\nComplete the following steps:\n1. Create class called `BankAccount`\n2. Use typical info about bank accounts to design attributes, such as the account number, the owner name, and the available funds.\n3. Specify access so that member data are protected from other parts of the program.\n4. Create accessor and mutator functions for member data.",
              "instructor_notes": ""
            },
            {
              "id": 830923,
              "key": "4754a9b6-d9c4-45a9-a3a6-505a48b9aac3",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-l58d4",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Encapsulation_Lab2.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826838,
          "key": "1cb383fb-7c91-4626-9f3e-63b2aff3df20",
          "title": "Mutator Functions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1cb383fb-7c91-4626-9f3e-63b2aff3df20",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909581,
              "key": "62ef5246-83ab-4183-9ac5-136626109656",
              "title": "Mutators",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "-WRtCE3MZB8",
                "china_cdn_id": "-WRtCE3MZB8.mp4"
              }
            },
            {
              "id": 826843,
              "key": "899b4591-60e2-4c58-b8ad-8177e32a27c4",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Mutator Functions\n\nA mutator (\"setter\") function can apply logic (\"invariants\") when updating member data. \n\n## Exercise: Car Class\n\nIn this lab you will create a setter method that receives data as an argument an converts it to a different type. Specifically, you will receive a string as input and convert it to a character array.\n\n1. Create a class called `Car`.\n2. Create 3 member variables: `horsepower`, `weight` and `brand`. The `brand` attribute must be a character array.\n3. Create accessor and mutator functions for all member data. The mutator function for `brand` must accept a C++ string as a parameter and convert that string into a [C-style string](https://www.learncpp.com/cpp-tutorial/66-c-style-strings/) (a character array ending in null character) to set the value of `brand`.\n4. The accessor function for the `brand` must return a string, so in this function you first will need to convert `brand` to `std::string`, and then return it.",
              "instructor_notes": ""
            },
            {
              "id": 830926,
              "key": "4bc465aa-47cb-4fa5-8389-f9bd4115bae0",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-zwhch",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Encapsulation_Lab3.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 833014,
          "key": "4cdaffca-b294-479b-a0ce-05edb3c90a12",
          "title": "Quiz: Classes in C++",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "4cdaffca-b294-479b-a0ce-05edb3c90a12",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 833015,
              "key": "ba50ab90-9759-4ec5-8844-a3cd52c68271",
              "title": "Class Constructor",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "ba50ab90-9759-4ec5-8844-a3cd52c68271",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "**The constructor function of a class is a special member function that defines any input parameters or logic that must be included upon instantiation of a class. From what you've seen so far is it required to define a constructor in C++ classes?**",
                "answers": [
                  {
                    "id": "a1551564505602",
                    "text": "No, if undefined C++ will define a default constructor",
                    "is_correct": true
                  },
                  {
                    "id": "a1551564746563",
                    "text": "Yes, without a constructor defined you cannot instantiate a class. ",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 833016,
              "key": "99028929-02a8-4b7f-b1ae-8d790de5139f",
              "title": "Access Modifiers",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "99028929-02a8-4b7f-b1ae-8d790de5139f",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "**What are the three options for access modifiers in C++?**",
                "answers": [
                  {
                    "id": "a1551564849247",
                    "text": "Public (access to anyone), Private (access only within the class) and Permitted (access in friend classes)",
                    "is_correct": false
                  },
                  {
                    "id": "a1551564959137",
                    "text": "Public (access to anyone), Protected (access in friend classes) and Permitted (access only within the class)",
                    "is_correct": false
                  },
                  {
                    "id": "a1551564971916",
                    "text": "Public (access to anyone), Private (access only within the class) and Protected (access in friend classes)",
                    "is_correct": true
                  },
                  {
                    "id": "a1551627848116",
                    "text": "Public (access in friend classes), Private (access only within the class) and Protected (access to anyone)",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 833017,
              "key": "b291932a-e6fe-4334-8db5-bfc7b8a44fdb",
              "title": "Setters and Getters",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "b291932a-e6fe-4334-8db5-bfc7b8a44fdb",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "**Why does it make sense to specify private member variables with accessor and mutator functions, instead of public member variables?**",
                "answers": [
                  {
                    "id": "a1551565138804",
                    "text": "It doesn't matter actually, you could just as well make them public.",
                    "is_correct": false
                  },
                  {
                    "id": "a1551565214211",
                    "text": "Using getter and setter functions is the only way to modify class member variables in C++.",
                    "is_correct": false
                  },
                  {
                    "id": "a1551565252214",
                    "text": "Often times you want to limit the user's access to class member variables, possibly because of an invariant.",
                    "is_correct": true
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 826847,
          "key": "1850ff2c-3d0b-4e14-a17e-9513cfd593dc",
          "title": "Exercise: Pyramid Class",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1850ff2c-3d0b-4e14-a17e-9513cfd593dc",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909582,
              "key": "122999ed-1b5b-4111-8526-72604fb75693",
              "title": "Pyramid",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "g3CM02Bnamk",
                "china_cdn_id": "g3CM02Bnamk.mp4"
              }
            },
            {
              "id": 827536,
              "key": "660fc43f-8bc0-4da1-89aa-dcf4c8fc7d36",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Exercise: Pyramid Class\n\n1. Create a class: `Pyramid`.\n2. Create 3 attributes: `length`, `width`, and `height`.\n3. Create a constructor to initialize all the attributes.\n4. Create accessor and mutator functions for all attributes. \n5. Think about the appropriate invariants and enforce them by throwing exceptions.\n6. Create a member function to calculate the volume of the pyramid.\n7. Optional: create a member function to calculate the surface area of the pyramid.\n\n## Volume\n\nThe volume of a pyramid is [length \\* width \\* height / 3](https://www.wikihow.com/Calculate-the-Volume-of-a-Pyramid). ",
              "instructor_notes": ""
            },
            {
              "id": 830927,
              "key": "b407b235-9988-4f88-a7c4-f0910110994c",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-feau7",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Encapsulation_Lab4.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 826437,
          "key": "a4b10c1a-e65f-4649-b2b2-e5e461dfb9c8",
          "title": "Exercise: Student Class",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "a4b10c1a-e65f-4649-b2b2-e5e461dfb9c8",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909585,
              "key": "d5f6d26e-7e53-4bd8-9f31-447ec5817891",
              "title": "Student",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "--WHwiY1Z1k",
                "china_cdn_id": "--WHwiY1Z1k.mp4"
              }
            },
            {
              "id": 826834,
              "key": "a2bbe67d-f2ee-49f8-8d75-bfae33906ca7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Exercise: Student Class\nYour goal in this lab is to write a class called `Student` that will hold data about a particular student. Your class simply needs to store the data and provide accessors and mutators.\n\n## Directions\n1. Add 3 _private_ member variables to the class:\n - Name\n - Grade (e.g. 9th grade)\n - Grade Point Average\n2. Write a public constructor function to set the private attributes.\n3. Create _public_ member functions to set each of the member variables. Before setting the values verify that:\n - Grade is from 0 (kindergarten) to 12\n - GPA is from 0.0 to 4.0\n - The function must either throw an exception if any of the invariants are violated\n4. Within the `main()` (outside of the class), declare an object of type `Student` and test out each of the member function calls.",
              "instructor_notes": ""
            },
            {
              "id": 827604,
              "key": "84738817-924b-4e5e-a381-ee793bb6c4bc",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-zzg7x",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Encapsulation_Lab1.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 833237,
          "key": "93d639e7-c680-4e8a-b3cc-01d54bc5b22a",
          "title": "Encapsulation in C++",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "93d639e7-c680-4e8a-b3cc-01d54bc5b22a",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 833238,
              "key": "1ac73029-8580-4a32-b67e-4fde193b0d00",
              "title": "Encapsulation Definition",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "1ac73029-8580-4a32-b67e-4fde193b0d00",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "**In the context of object oriented programming, encapsulation refers to:**",
                "answers": [
                  {
                    "id": "a1551627270145",
                    "text": "A requirement that data and logic be packaged separately in distinct objects",
                    "is_correct": false
                  },
                  {
                    "id": "a1551627354270",
                    "text": "The notion that data and logic can be packaged together and passed around within a program as a single object.",
                    "is_correct": true
                  },
                  {
                    "id": "a1551627429227",
                    "text": "The restriction that logic within a particular object can only operate on data stored within that same object.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 833239,
              "key": "9b0581cd-6a79-473b-b857-e99f531025be",
              "title": "Keyword const",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "9b0581cd-6a79-473b-b857-e99f531025be",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "**Invoking the `const` keyword in an accessor function allows you to:**",
                "answers": [
                  {
                    "id": "a1551627987086",
                    "text": "Require that the data type of the output will be the same as that of the input.",
                    "is_correct": false
                  },
                  {
                    "id": "a1551628051743",
                    "text": "Ensure the user cannot do anything to change the private attributes of the object.",
                    "is_correct": true
                  },
                  {
                    "id": "a1551628076589",
                    "text": "Pass in constant attribute values to the accessor function.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 833240,
              "key": "e1d052d8-f519-4bad-93c6-242a4a408463",
              "title": "Setter function",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "e1d052d8-f519-4bad-93c6-242a4a408463",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "**Making class attributes private and assigning them with a mutator function allows you to:**",
                "answers": [
                  {
                    "id": "a1551628403977",
                    "text": "Ensure that only class member functions have access to private class attributes.",
                    "is_correct": false
                  },
                  {
                    "id": "a1551628491557",
                    "text": "Invoke logic that checks whether the input data are valid before setting attributes.",
                    "is_correct": true
                  },
                  {
                    "id": "a1551628519477",
                    "text": "Prevent users from changing non-public class attributes.",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 845687,
          "key": "36024274-dbb5-45b9-91d4-470dc03d8281",
          "title": "Bjarne On Abstraction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "36024274-dbb5-45b9-91d4-470dc03d8281",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845688,
              "key": "15c232ae-2c7a-4ad9-89d2-755ecb136e65",
              "title": "ND213 C02 Abstraction What Is Absctraction-",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "eUf7QBJNIFc",
                "china_cdn_id": "eUf7QBJNIFc.mp4"
              }
            }
          ]
        },
        {
          "id": 826426,
          "key": "acbe1b00-bf8a-477a-9bfa-884824b0ead7",
          "title": "Abstraction",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "acbe1b00-bf8a-477a-9bfa-884824b0ead7",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909586,
              "key": "ea9493d1-7720-44ad-b71a-3db095ee88d6",
              "title": "Abstraction",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "C0MJyP0dOhU",
                "china_cdn_id": "C0MJyP0dOhU.mp4"
              }
            },
            {
              "id": 826432,
              "key": "66ad8f55-3de9-4eb8-93d5-fa42a5b917c3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Abstraction\nAbstraction refers to the separation of a class's interface from the details of its implementation. The interface provides a way to interact with an object, while hiding the details and implementation of how the class works.\n\n## Example\nThe `String()` function within this `Date` class is an example of abstraction.\n\n```cpp\nclass Date {\n public:\n  ...\n  std::string String() const;\n  ...\n};\n```\nThe user is able to interact with the `Date` class through the `String()` function, but the user does not need to know about the implementation of either `Date` or `String()`. \n\nFor example, the user does not know, or need to know, that this object internally contains three `int` member variables. The user can just call the `String()` method to get data. \n\nIf the designer of this class ever decides to change how the data is stored internally -- using a vector of `int`s instead of three separate `int`s, for example -- the user of the `Date` class will not need to know.",
              "instructor_notes": ""
            },
            {
              "id": 830954,
              "key": "d6eb262a-8a99-4bd5-bcd0-b5743167a8fc",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-9hng0",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Abstraction_Example.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827499,
          "key": "8c3ee090-e3dd-43cd-80a3-44dbf8967552",
          "title": "Exercise: Sphere Class",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "8c3ee090-e3dd-43cd-80a3-44dbf8967552",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909587,
              "key": "aef28288-d9be-4642-aee0-5490e3ec20ab",
              "title": "Sphere",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "S5iKMpA-gFE",
                "china_cdn_id": "S5iKMpA-gFE.mp4"
              }
            },
            {
              "id": 827538,
              "key": "ccf4bc06-90fa-48cf-96a7-184ccd90a661",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Exercise: Sphere Class\nIn this exercise you will practice abstraction by creating a class which represents a sphere. \n\nDeclare:\n1. A constructor function that takes the radius as an argument\n2. A member function that returns the [volume](https://www.google.com/search?q=sphere+volume)\n\n## Directions\n\n1. Define a class called `Sphere`.\n2. Add one private member variable: `radius`.\n3. Define a constructor to initialize the radius.\n4. Define an accessor method that returns the radius.\n4. Define a member function to return the volume of the sphere.\n5. Write a `main()` function to initialize an object of type `Sphere`.",
              "instructor_notes": ""
            },
            {
              "id": 830957,
              "key": "67f99a05-781a-41ed-a4e7-32a986d4d684",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-f7uq9",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/SphereClass.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827501,
          "key": "7df06e34-c5c0-46bd-a103-e812cb97c89c",
          "title": "Exercise: Private Method",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7df06e34-c5c0-46bd-a103-e812cb97c89c",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909588,
              "key": "196bc8b0-eecb-43f2-8f8b-25a72e60868b",
              "title": "Sphere2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Z75_sEnapD4",
                "china_cdn_id": "Z75_sEnapD4.mp4"
              }
            },
            {
              "id": 827539,
              "key": "e0d9501a-f2d6-42ad-aaa9-d6c209343758",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Exercise: Private Method\n\nAbstraction is used to expose only relevant information to the user. By hiding implementation details, we give ourselves flexibility to modify how the program works. In this example, you'll practice abstracting implementation details from the user.\n\n## Directions\n\nIn this exercise, you'll update the `class Sphere` so that it becomes possible to change the radius of a sphere after it has been initialized. In order to do this, you'll move the two [class invariants](https://en.wikipedia.org/wiki/Class_invariant) into private member functions.\n\n1. Move the range-check on `radius_` into a private member function.\n2. Move the `volume_` calculation, which depends on the value of `radius_` into the same private member function.\n3. Verify that the class still functions correctly.\n4. Add a mutator method to change the radius of an existing `Sphere`.\n5. Verify that the mutator method successfully updates both the radius and the volume.",
              "instructor_notes": ""
            },
            {
              "id": 830958,
              "key": "939b3d3f-8059-403c-a741-6967b2ab3e86",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-893re",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Abstraction_Lab3.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827504,
          "key": "55846166-3457-412e-986e-a574c1f90a31",
          "title": "Exercise: Static Members",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "55846166-3457-412e-986e-a574c1f90a31",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 909589,
              "key": "a69071be-4aa6-4346-84b4-1f1f4e509197",
              "title": "Static",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "7fBkcIL6d8k",
                "china_cdn_id": "7fBkcIL6d8k.mp4"
              }
            },
            {
              "id": 827540,
              "key": "328ce869-ec1b-4aec-a712-2fdcaa10985d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Static Members\n\nClass members can be declared `static`, which means that the member belongs to the entire class, instead of to a specific instance of the class. More specifically, a `static` member is created only once and then shared by all instances (i.e. objects) of the class. That means that if the `static` member gets changed, either by a user of the class or within a member function of the class itself, then all members of the class will see that change the next time they access the `static` member.",
              "instructor_notes": ""
            },
            {
              "id": 833225,
              "key": "914bf9ce-3feb-4b67-ba24-d38cc43bb6fb",
              "title": "A second static counter",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "914bf9ce-3feb-4b67-ba24-d38cc43bb6fb",
                "completed_at": null,
                "last_viewed_at": null,
                "unstructured": null
              },
              "question": {
                "prompt": "Imagine you have a `class Sphere` with a `static int counter` member. `Sphere` increments `counter` in the constructor and uses this to track how many `Sphere`s have been created. What would happen if you instantiated a new classes (`Cube`, for instance) that also had a `static int counter`? Would the two `counter`s conflict?",
                "answers": [
                  {
                    "id": "a1551573735345",
                    "text": "Yes, instantiating a class of a different name that has a static attribute `counter` will increment the same `counter` as before.",
                    "is_correct": false
                  },
                  {
                    "id": "a1551573941894",
                    "text": "No, because the new static attribute `counter` is defined within the `Cube` class, it has nothing to do with `Sphere::counter`.",
                    "is_correct": true
                  },
                  {
                    "id": "a1551573992530",
                    "text": "Only if both classes are instantiated within the same scope do the two `counter` attributes conflict.",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 859792,
              "key": "4ede2b71-1aa5-4ddc-a957-797209575527",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Implementation\n`static` members are **declared** within their `class` (often in a header file) but in most cases they must be **defined** within the global scope. That's because memory is allocated for `static` variables immediately when the program begins, at the same time any global variables are initialized.\n\nHere is an example:\n```\n#include <cassert>\n\nclass Foo {\n public:\n  static int count;\n  Foo() { Foo::count += 1; }\n};\n\nint Foo::count{0};\n\nint main() {\n  Foo f{};\n  assert(Foo::count == 1);\n}\n```\nAn exception to the global definition of `static` members is if such members can be marked as [`constexpr`](https://en.cppreference.com/w/cpp/language/constexpr). In that case, the `static` member variable can be both declared and defined within the `class` definition:\n```\nstruct Kilometer {\n  static constexpr int meters{1000};\n};\n```",
              "instructor_notes": ""
            },
            {
              "id": 859794,
              "key": "e3d38090-917c-46ce-943b-9824867dcc22",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: Pi\n`class Sphere` has a member `const double pi`. Experiment with specifying `pi` to be `const`, `constexpr`, and `static`. Which specifications work and which break? Do you understand why?",
              "instructor_notes": ""
            },
            {
              "id": 830959,
              "key": "5e66b9fb-1e91-4f0b-9599-4f079d7c02b3",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-ks7hl",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Abstraction_Lab4.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 827506,
          "key": "6600fd93-fa87-4305-a419-963a56e5bffc",
          "title": "Exercise: Static Methods",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6600fd93-fa87-4305-a419-963a56e5bffc",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 827542,
              "key": "ee5a0e1c-b2e1-4efb-b70c-2fc5fbed9e9b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Exercise: Static Method\n\nIn addition to `static` member variables, C++ supports `static` member functions (or \"methods\"). Just like `static` member variables, `static` member functions are instance-independent: they belong to the class, not to any particular instance of the class. \n\nOne corollary to this is that we can method invoke a `static` member function *without ever creating an instance of the class*. \n\nYou will try just that in this exercise.\n\n## Instructions\n1. Refactor `class Sphere` to move the volume calculation into a `static` function.\n2. Verify that the class still functions as intended.\n3. Make that `static` function public.\n4. Call that static function directly from `main()` to calculate the hypothetical volume of a sphere you have not yet instantiated.",
              "instructor_notes": ""
            },
            {
              "id": 909590,
              "key": "32034c89-0b24-4140-9f16-a029dd6d3686",
              "title": "Static2",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "8ezbkN76msY",
                "china_cdn_id": "8ezbkN76msY.mp4"
              }
            },
            {
              "id": 830960,
              "key": "19e2f287-083f-4ac3-b5c8-5c16c4711fd2",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "r812755c826361xJUPYTERqnsj8n34",
              "pool_id": "jupyter",
              "view_id": "jupyter-npzqi",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "ports": [],
                    "allowGrade": false,
                    "allowSubmit": false,
                    "defaultPath": "/notebooks/Abstraction_Lab5.ipynb"
                  },
                  "kind": "jupyter"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 833255,
          "key": "2a4cfa64-1ff2-41ec-b9b2-b67234eb6e9b",
          "title": "Bjarne On Solving Problems",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "2a4cfa64-1ff2-41ec-b9b2-b67234eb6e9b",
            "completed_at": null,
            "last_viewed_at": null,
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 845743,
              "key": "12f928b9-db13-45b9-bab3-6a7ee42157d5",
              "title": "ND213 C02 Modeling The World How Should A Programmer Think Abt Classes",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "Jo1NTa-krEE",
                "china_cdn_id": "Jo1NTa-krEE.mp4"
              }
            },
            {
              "id": 845740,
              "key": "208b5254-5861-4d9d-853a-058a68c2c756",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Well Done!\nGreat job working through `Classes`, `Encapsulation` and `Abstraction`! Let us move on to more advanced topics of OOP in C++.",
              "instructor_notes": ""
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}